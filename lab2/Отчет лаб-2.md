# Лабораторная 2
## Задание: 
Реализовать программу для накладывания фильтров на изображения. Возможные фильтры: размытие, выделение границ, избавление от шума. Измерить время.

Для работы с графическими файлами рекомендуется использовать libpng (man libpng). Примеры использования библиотеки в /usr/share/doc/libpng12-dev/examples/

Считать изображение из файла, преобразовать в массив, отправить на CUDA Device, провести на устройстве обработку фильтром, вернуть изображение в память хоста, преобразовать в картинку, сохранить файл.

## Ход работы
1.Задание было выполнено на кластере cluster-gpn.nsu.ru

2.Было реализовано три фильтра - гауссовское размытие, фильтр Собеля, медианный фильтр.

3.В качестве изображений (.png) было выбрано два:

    -Изображение№1 (cat1.png):280*210
    -Изображение№1 (cat2.png): 1811*1017

4.Расчет времени (milliseconds) выполнения на GPU и CPU.

Перед запуском ядер был выполнен их разогрев!

## Результаты
**Размер картинки: 280*210**

GPU

Filter

#### blur: 0.02
#### edge: 0.02
#### denoise: 0.03

____

CPU

Filter

#### blur: 33.72
#### edge: 37.22
#### denoise: 67.33

____

**Размер картинки: 1811*1017**

GPU

Filter

#### blur: 0.15
#### edge: 0.14
#### denoise: 0.31

_____

CPU

Filter

#### blur: 1068.48
#### edge: 1164.42
#### denoise: 2426.26

## Выводы:

    1.На GPU самую высокую производительность получаем при применении гауссовского размытия и фильтра Собеля, поскольку 
    для реализации данных фильтров требуются простые арифметические операции (сложения и умножения). В то время как для
    медианного фильтра требуется собрать 9 соседей и выпольнить пузырьковую сортировку.
    2.На CPU в целом тенденция сохраняется.

## применение тернарного оператора к функциям обработки границ (reflect_index, clamp_reflect_index, cpu_clamp_reflect_index):

__device__ __forceinline__ int reflect_index(int index, int limit) {

    return (index < 0) ? -index : (index >= limit ? 2 * limit - index - 2 : index);
    
}

__device__ __forceinline__ int clamp_reflect_index(int index, int limit) {

    if (limit <= 1) return 0;
    
    index = reflect_index(index, limit);
    
    while (index < 0 || index >= limit) {
    
        index = (index < 0) ? -index : (2 * limit - index - 2);
        
    }
    
    return index;
    
}

inline int cpu_clamp_reflect_index(int index, int limit) {

    if (limit <= 1) return 0;
    
    auto reflect = [](int v, int lim) {
    
        return (v < 0) ? -v : (v >= lim ? 2 * lim - v - 2 : v);
        
    };
    
    index = reflect(index, limit);
    
    while (index < 0 || index >= limit) {
    
        index = (index < 0) ? -index : (2 * limit - index - 2);
        
    }
    
    return index;
    
}

## Сравнение результатов ДО и ПОСЛЕ применения тернарного оператора
**Размер картинки: 280*210**

GPU

Filter

#### blur: (было 0.02)
#### edge: (было 0.02)
#### denoise: (было 0.03)

____

CPU

Filter

#### blur:  (было 33.72)
#### edge:  (было 37.22)
#### denoise:  (было 67.33)

____

**Размер картинки: 1811*1017**

GPU

Filter

#### blur:  (было 0.15)
#### edge:  (было 0.14)
#### denoise:  (было 0.31)

_____

CPU

Filter

#### blur: (было 1068.48)
#### edge: (было 1164.42)
#### denoise: (было 2426.26)

## Визуализация для изображения№1:
![Описание изображения](cat_1.png)
![Описание изображения](output_blur_1.png)
![Описание изображения](output_denoise_1.png)
![Описание изображения](output_edge_1.png)
## Визуализация для изображения№2:
![Описание изображения](images.png)
![Описание изображения](output_blur_3.png)
![Описание изображения](output_denoise_3.png)
![Описание изображения](output_edge_3.png)
